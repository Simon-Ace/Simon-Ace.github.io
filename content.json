{"meta":{"title":"Rookie的博客","subtitle":"Stay hungry. Stay foolish.","description":null,"author":"Simon","url":"https://simon-ace.github.io","root":"/"},"pages":[],"posts":[{"title":"vim 常用操作","slug":"vim 常用操作","date":"2020-09-16T16:00:00.000Z","updated":"2020-09-17T03:12:52.618Z","comments":true,"path":"2020/09/17/vim 常用操作/","link":"","permalink":"https://simon-ace.github.io/2020/09/17/vim 常用操作/","excerpt":"12# 取消高亮:noh","text":"12# 取消高亮:noh 取消搜索后高亮 1234# no high light search:nohlsearch# 简写:noh","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"vim, 教程","slug":"vim-教程","permalink":"https://simon-ace.github.io/tags/vim-教程/"}]},{"title":"Linux压缩命令","slug":"Linux压缩命令","date":"2020-08-31T16:00:00.000Z","updated":"2020-09-01T02:41:59.205Z","comments":true,"path":"2020/09/01/Linux压缩命令/","link":"","permalink":"https://simon-ace.github.io/2020/09/01/Linux压缩命令/","excerpt":"12345678# 解压 tar包tar -xvf file.tar # 解压tar.gztar -xzvf file.tar.gz # 1.15版本后 tar 自动识别压缩方式tar -xvf filename.tar.gz","text":"12345678# 解压 tar包tar -xvf file.tar # 解压tar.gztar -xzvf file.tar.gz # 1.15版本后 tar 自动识别压缩方式tar -xvf filename.tar.gz 一、常用压缩参数必选参数，压缩解压都要用到其中一个： -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 可选参数： -z：有gzip属性的 -j： 有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 二、举个栗子压缩 1234567891011# 将目录里所有jpg文件打包成tar.jpgtar -cvf jpg.tar *.jpg # 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar -czf jpg.tar.gz *.jpg # rar格式的压缩，需要先下载rar for linuxrar a jpg.rar *.jpg # zip格式的压缩，需要先下载zip for linuxzip jpg.zip *.jpg 解压 1234567891011121314# 解压 tar包tar -xvf file.tar # 解压tar.gztar -xzvf file.tar.gz # 解压 tar.bz2tar -xjvf file.tar.bz2 # 解压rarunrar e file.rar # 解压zipunzip file.zip 从1.15版本开始tar就可以自动识别压缩的格式,故不需人为区分压缩格式就能正确解压 1234tar -xvf filename.tar.gztar -xvf filename.tar.bz2tar -xvf filename.tar.xztar -xvf filename.tar.Z","categories":[{"name":"技术","slug":"技术","permalink":"https://simon-ace.github.io/categories/技术/"}],"tags":[{"name":"Linux, 压缩","slug":"Linux-压缩","permalink":"https://simon-ace.github.io/tags/Linux-压缩/"}]},{"title":"构建Hadoop的Docker编译环境","slug":"构建 Hadoop 的 Docker 编译环境","date":"2020-08-31T16:00:00.000Z","updated":"2020-09-02T02:47:19.693Z","comments":true,"path":"2020/09/01/构建 Hadoop 的 Docker 编译环境/","link":"","permalink":"https://simon-ace.github.io/2020/09/01/构建 Hadoop 的 Docker 编译环境/","excerpt":"","text":"一、配置 docker 环境 参考链接：Hadoop安装之一：使用Docker编译64位的Hadoop - 简书 1. 制作 CentOS 7 基础镜像（可选）Docker Hub上已经提供了CentOS7的官方镜像，但并未激活 Systemd（用来启动守护进程），制作一个启动 Systemd 的镜像。（这里编译Hadoop其实用不到systemd） Dockerfile 1234567891011121314151617181920212223242526# 镜像来源FROM centos:7# 镜像创建者MAINTAINER \"you\" &lt;your@email.here&gt;# 设置一个环境变量ENV container docker# 运行命令# 设置systemdRUN (cd /lib/systemd/system/sysinit.target.wants/; for i in *; do [ $i == \\systemd-tmpfiles-setup.service ] || rm -f $i; done); \\rm -f /lib/systemd/system/multi-user.target.wants/*;\\rm -f /etc/systemd/system/*.wants/*;\\rm -f /lib/systemd/system/local-fs.target.wants/*; \\rm -f /lib/systemd/system/sockets.target.wants/*udev*; \\rm -f /lib/systemd/system/sockets.target.wants/*initctl*; \\rm -f /lib/systemd/system/basic.target.wants/*;\\rm -f /lib/systemd/system/anaconda.target.wants/*;# 挂载一个本地文件夹VOLUME [ \"/sys/fs/cgroup\" ]# 设置容器启动时的执行命令CMD [\"/usr/sbin/init\"] 生成镜像 1docker build -t centos7-systemd . 2. 安装 Oracle Java 参考链接使用yum卸载、安装jdk_不做小白的博客-CSDN博客 注意不要使用 openjdk，会导致编译 hive 时出现问题 启动刚刚生成的镜像 从官网下载 oracle java jdk-8u202-linux-x64.tar.gz 安装 Java，配置环境变量 12345678910111213141516171819mkdir /usr/local/javacp jdk-8u202-linux-x64.tar.gz /usr/local/javacd /usr/local/javatar -xzvf jdk-8u202-linux-x64.tar.gz# 配置环境变量vim /etc/profile~~export JAVA_HOME=/usr/local/java/jdk1.8.0_202export JRE_HOME=/usr/local/java/jdk1.8.0_202/jre export PATH=$PATH:/usr/local/java/jdk1.8.0_202/bin export CLASSPATH=./:/usr/local/java/jdk1.8.0_202/lib:/usr/local/java/jdk1.8.0_202/jre/lib~~source /etc/profile# 检查 JAVA 是否安装成功java -version 保存镜像 1docker commit 容器id 镜像名 3. 制作编译镜像 编译脚本 1234567891011121314151617181920$ vi compile.sh#!/bin/bash# 设置默认编译版本(支持传参)version=$&#123;1:-2.7.3&#125;# 进入源代码目录cd /hadoop-$version-src# 开始编译echo -e \"\\n\\ncompile hadoop $version...\"mvn clean package -Pdist,native -DskipTests -Dtar# 输出结果if [[ $? -eq 0]]; then echo -e \"\\n\\ncompile hadoop $version success!\\n\\n\"else echo -e \"\\n\\ncompile hadoop $version fail!\\n\\n\"fi Dockerfile（其中有不少安装包不是必要的） 123456789101112131415161718192021222324252627# 镜像来源(第二步生成的本地镜像)FROM centos7-systemd-java# 镜像创建者MAINTAINER \"you\" &lt;your@email.here&gt;# 运行命令安装环境依赖# 使用 -y 同意全部询问RUN yum update -y &amp;&amp; \\ yum groupinstall -y \"Development Tools\" &amp;&amp; \\ yum install -y wget \\ protobuf-devel \\ protobuf-compiler \\ maven \\ cmake \\ pkgconfig \\ openssl-devel \\ zlib-devel \\ gcc \\ automake \\ autoconf \\ make # 复制编辑脚本文件到镜像中COPY compile.sh /root/compile.sh# 设置脚本文件的可运行权限RUN chmod +x /root/compile.sh 生成镜像 1sudo docker build -t centos7-hadoop-compiler . 二、编译源码 hive（大概10分钟） 1mvn clean package -Pdist -DskipTests hadoop（大概15分钟） 1mvn clean package -Pdist,native -DskipTests -Dtar 也可以使用 docker image 中的脚本编译 12$ export VERSION=2.7.3$ sudo docker run -v $(pwd)/hadoop-$VERSION-src:/hadoop-$VERSION-src --privileged=true centos7-hadoop-complier /root/compile.sh $VERSION 要添加 privileged 参数！ [docker]privileged参数_追寻神迹-CSDN博客 使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。 总结 1234567891011121314151617181920212223242526272829# pull docker imagedocker pull shuofxz/hadoop-compiler:1.0# === HADOOP ===# hadoop download link# new versionhttps://hadoop.apache.org/releases.html# old versionhttps://archive.apache.org/dist/hadoop/common/# compile command (about 15 minutes to complete)mvn package -Pdist,native -DskipTests -Dtar# compile with script file$ export VERSION=2.7.3$ sudo docker run -v $(pwd)/hadoop-$VERSION-src:/hadoop-$VERSION-src --privileged=true shuofxz/hadoop-compiler:1.0 /root/hadoop-compile.sh $VERSION# === HIVE ===# hive download link# select corresponding branch src file to downloadhttps://github.com/apache/hive# compile command (about 10 minutes to complete)mvn clean package -Pdist -DskipTests# compile with script file$ export VERSION=2.3.0$ sudo docker run -v $(pwd)/hive-rel-release-$VERSION:/hive-rel-release-$VERSION --privileged=true shuofxz/hadoop-compiler:1.0 /root/hive-compile.sh $VERSION hadoop-2.7.0-src.tar.gz release-2.3.0.tar.gz 已包括各种库的 image，可以直接编译 hadoop（不好用） GitHub - kiwenlau/compile-hadoop: Compile Hadoop in Docker containerhttps://github.com/kiwenlau/compile-hadoop","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"docker,教程","slug":"docker-教程","permalink":"https://simon-ace.github.io/tags/docker-教程/"}]},{"title":"Docker 批量操作","slug":"Docker 批量操作","date":"2020-08-27T16:00:00.000Z","updated":"2020-09-01T10:04:59.753Z","comments":true,"path":"2020/08/28/Docker 批量操作/","link":"","permalink":"https://simon-ace.github.io/2020/08/28/Docker 批量操作/","excerpt":"1docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;')","text":"1docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;') 列出所有的容器 ID 1docker ps -aq 停止所有的容器 1docker stop $(docker ps -aq) 删除所有的容器 1docker rm $(docker ps -aq) 删除所有的镜像 1docker rmi $(docker images -q) 删除指定名称镜像 1docker rmi $(docker images | grep \"none\" | awk '&#123;print $3&#125;') 复制文件 12docker cp mycontainer:/opt/file.txt /opt/local/docker cp /opt/local/file.txt mycontainer:/opt/ 现在的docker有了专门清理资源(container、image、网络)的命令。 docker 1.13 中增加了 docker system prune的命令，针对container、image可以使用docker container prune、docker image prune命令。 删除所有不使用的镜像 123docker image prune --force --all# ordocker image prune -f -a 删除所有停止的容器 1docker container prune -f","categories":[{"name":"技术","slug":"技术","permalink":"https://simon-ace.github.io/categories/技术/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://simon-ace.github.io/tags/docker/"}]},{"title":"Cron语法","slug":"cron语法","date":"2020-08-16T16:00:00.000Z","updated":"2020-08-17T10:33:34.460Z","comments":true,"path":"2020/08/17/cron语法/","link":"","permalink":"https://simon-ace.github.io/2020/08/17/cron语法/","excerpt":"12* * * * * * *秒 分钟 小时 天 月 星期 年","text":"12* * * * * * *秒 分钟 小时 天 月 星期 年 1 表达式详解一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。 按顺序依次为 1 秒（0~59） 2 分钟（0~59） 3 小时（0~23） 4 天（0~31） 5 月（0~11） 6 星期（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT） 7 年份（1970－2099） 每个元素格式： 一个具体值（如6） 一个连续区间（9-12） 一个列表(1,3,5) 特殊字符 通配符（*），所有可能的值 空符号（？），表示不指定值 由于”月份中的日期”和”星期中的日期”这两个元素互斥的,必须要对其中一个设置? 增量符（/） 如第二位12/10 表示从第12分钟开始，每10分钟（它和“12，22，32…”） 最后（L） 仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 “6L”表示这个月的倒数第６天 平日（W） 仅能用于日域中，它用来指定离指定日的最近的一个工作日（1-5） 日域中的 15W 意味着 “离该月15号的最近一个平日 2 例子123456789101112130 0 10,14,16 * * ? 每天上午10点，下午2点，4点0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时0 0 12 ? * WED 表示每个星期三中午12点0 0 12 * * ? 每天中午12点触发0 15 10 ? * * 每天上午10:15触发0 15 10 * * ? 2005 2005年的每天上午10:15触发0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发0 15 10 ? * MON-FRI 周一至周五的上午10:15触发0 15 10 L * ? 每月最后一日的上午10:15触发0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发","categories":[{"name":"技术","slug":"技术","permalink":"https://simon-ace.github.io/categories/技术/"}],"tags":[{"name":"cron","slug":"cron","permalink":"https://simon-ace.github.io/tags/cron/"}]},{"title":"Hexo常用命令","slug":"Hexo常用命令","date":"2020-08-12T16:00:00.000Z","updated":"2020-08-13T10:18:27.861Z","comments":true,"path":"2020/08/13/Hexo常用命令/","link":"","permalink":"https://simon-ace.github.io/2020/08/13/Hexo常用命令/","excerpt":"123456# 生成静态文件hexo g# 启动服务hexo s# 部署hexo d","text":"123456# 生成静态文件hexo g# 启动服务hexo s# 部署hexo d 常用命令 生成静态文件 123hexo generate# 简写hexo g 启动服务预览文章 12345hexo server# 简写hexo s# 指定端口hexo server -p 5000 一键部署 123hexo deploy# 简写hexo d","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simon-ace.github.io/tags/Hexo/"}]},{"title":"","slug":"Docker部署Vue项目","date":"2020-08-12T07:02:40.098Z","updated":"2020-08-12T07:02:43.859Z","comments":true,"path":"2020/08/12/Docker部署Vue项目/","link":"","permalink":"https://simon-ace.github.io/2020/08/12/Docker部署Vue项目/","excerpt":"","text":"[手把手系列之]Docker 部署 vue 项目 - 掘金https://juejin.im/post/6844903837774397447","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-10T03:23:10.782Z","updated":"2020-07-10T03:23:10.782Z","comments":true,"path":"2020/07/10/hello-world/","link":"","permalink":"https://simon-ace.github.io/2020/07/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Mac使用代理ssh远程连接服务器","slug":"Mac使用代理ssh远程连接服务器","date":"2020-07-09T16:00:00.000Z","updated":"2020-07-10T11:51:05.513Z","comments":true,"path":"2020/07/10/Mac使用代理ssh远程连接服务器/","link":"","permalink":"https://simon-ace.github.io/2020/07/10/Mac使用代理ssh远程连接服务器/","excerpt":"123456# 直接连接ssh -p 端口号 服务器用户名@ip地址# eg: ssh -p 22 userkunyu@119.29.37.63# 通过代理连接ssh -o ProxyCommand=\"nc -X 5 -x 代理服务器ip:代理服务器端口 %h %p\" 需要访问的服务器的用户名@需要访问的服务器ip","text":"123456# 直接连接ssh -p 端口号 服务器用户名@ip地址# eg: ssh -p 22 userkunyu@119.29.37.63# 通过代理连接ssh -o ProxyCommand=\"nc -X 5 -x 代理服务器ip:代理服务器端口 %h %p\" 需要访问的服务器的用户名@需要访问的服务器ip 1 直接连接12# ssh -p 端口号 服务器用户名@ip地址ssh -p 22 userkunyu@119.29.37.63 2 通过代理连接 直接连接 12# ssh -o ProxyCommand=\"nc -X 5 -x 代理服务器ip:代理服务器端口 %h %p\" 需要访问的服务器的用户名@需要访问的服务器ipssh -o ProxyCommand=\"nc -X 5 -x 192.168.0.255:9999 %h %p\" user_name@192.168.77.200 使用SSH配置文件 1sudo vi ~/.ssh/config 12Host * ProxyCommand nc -X 5 -x 192.168.0.255:9999 %h %p 配置好了之后就可以和直接连接一样使用 1ssh uesr@ip Mac下SSH跳点连接及代理连接_Dawnworld-CSDN博客_mac ssh 代理https://blog.csdn.net/thundon/article/details/46858957","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/tags/教程/"}]},{"title":"Mac安装node","slug":"Mac安装node","date":"2020-07-09T16:00:00.000Z","updated":"2020-07-10T06:24:18.048Z","comments":true,"path":"2020/07/10/Mac安装node/","link":"","permalink":"https://simon-ace.github.io/2020/07/10/Mac安装node/","excerpt":"Mac安装及降级node版本","text":"Mac安装及降级node版本 1 安装最新版Node 安装HomeBrew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 安装Node 1brew install node 验证Node是否安装成功 输入下面两条指令看是否可以都输出版本号 12node -vnpm -v 2 降级Node由于开发需要或版本兼容性，需要安装低版本的Node，按下面的方式操作 卸载Node 如果你是按前面的方法安装的Node，则用下面的命令卸载 1brew uninstall node 查看可用的Node版本 1brew search node 输出结果： 12==&gt; Formulaelibbitcoin-node node node-sass node@12 nodebrew nodenv llnode node-build node@10 node_exporter nodeenv 安装你需要的版本 12# 这里安装v12版本brew install node@12 连接Node 12brew link node@12# 这一步可能会报错, 按照提示执行命令就ok了, 比如我最后执行的是brew link --overwrite --force node@12 检查Node是否安装成功 1node -v","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/tags/教程/"}]},{"title":"iTerm2配置","slug":"iTerm2配置","date":"2020-07-09T16:00:00.000Z","updated":"2020-07-10T10:23:28.607Z","comments":true,"path":"2020/07/10/iTerm2配置/","link":"","permalink":"https://simon-ace.github.io/2020/07/10/iTerm2配置/","excerpt":"iTerm2配置 Oh-my-zsh安装，主题配置","text":"iTerm2配置 Oh-my-zsh安装，主题配置 1 安装iTerm2iTerm2 是一款完全免费的，专为 Mac OS 用户打造的命令行应用。直接在官网上 http://iterm2.com/ 下载并安装即可。 设置为默认终端 2 安装 oh-my-zshbash是mac中terminal自带的shell，把它换成oh-my-zsh，这个的功能要多得多。拥有语法高亮，命令行tab补全，自动提示符，显示Git仓库状态等功能。 1sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 解决权限问题 如果安装完重启iterm之后，出现下面的提示： 12345[oh-my-zsh] Insecure completion-dependent directories detected:drwxrwxrwx 7 hans admin 238 2 9 10:13 /usr/local/share/zshdrwxrwxrwx 6 hans admin 204 10 1 2017 /usr/local/share/zsh/site-functions...... 解决方法： 12chmod 755 /usr/local/share/zshchmod 755 /usr/local/share/zsh/site-functions 3 配置主题4 Vim配置设置鼠标滚动","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/tags/教程/"}]},{"title":"Linux后台执行命令","slug":"Linux后台执行命令","date":"2019-10-21T16:00:00.000Z","updated":"2020-07-10T03:23:10.779Z","comments":true,"path":"2019/10/22/Linux后台执行命令/","link":"","permalink":"https://simon-ace.github.io/2019/10/22/Linux后台执行命令/","excerpt":"当在终端工作时，可能一个持续运行的作业占住屏幕输出，或终端退出时导致命令结束。为了避免这些问题，可以将这些进程放到后台运行，且不受终端关闭的影响，可使用下面的方法： 1nohup command &gt; myout.file 2&gt;&amp;1 &amp;","text":"当在终端工作时，可能一个持续运行的作业占住屏幕输出，或终端退出时导致命令结束。为了避免这些问题，可以将这些进程放到后台运行，且不受终端关闭的影响，可使用下面的方法： 1nohup command &gt; myout.file 2&gt;&amp;1 &amp; 1 后台执行命令1.1 命令&amp;在命令后面加上&amp;实现后台运行（控制台关掉(退出帐户时)，作业就会停止运行） 1command &amp; 例：python run.py &amp; 1.2 命令nohupnohup命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up) 1nohup command &amp; 例：nohup run.py &amp; 2 kill进程执行后台任务命令后，会返回一个进程号，可通过这个进程号kill掉进程。 1kill -9 进程号 3 输出重定向由于使用前面的命令将任务放到后台运行，因此任务的输出也不打印到屏幕上了，所以需要将输出重定向到文件中，以方便查看输出内容。 将输出重定向到 file（覆盖） 1command1 &gt; file1 将输出重定向到 file（追加） 1command1 &gt;&gt; file1 将 stdout 和 stderr 合并后重定向到 file 2&gt;1代表什么，2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出；换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出. 1command1 &gt; file1 2&gt;&amp;1 完整写法： 1nohup command &gt;out.file 2&gt;&amp;1 &amp; 4 其他 nohup执行python程序时，print无法输出 这是因为python的输出有缓冲，导致nohup.out并不能够马上看到输出 python 有个-u参数，使得python不启用缓冲 nohup python -u test.py &gt; nohup.out 2&gt;&amp;1 &amp;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://simon-ace.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://simon-ace.github.io/tags/Linux/"}]},{"title":"Linux统计文件夹下的文件数目","slug":"Linux统计文件夹下的文件数目","date":"2019-10-21T16:00:00.000Z","updated":"2020-07-10T03:23:10.780Z","comments":true,"path":"2019/10/22/Linux统计文件夹下的文件数目/","link":"","permalink":"https://simon-ace.github.io/2019/10/22/Linux统计文件夹下的文件数目/","excerpt":"1$ ls -l | grep &quot;^-&quot; | wc -l","text":"1$ ls -l | grep &quot;^-&quot; | wc -l 1 统计文件夹下的文件数目 统计当前目录下文件的个数（不包括目录） 1$ ls -l | grep &quot;^-&quot; | wc -l 统计当前目录下文件的个数（包括子目录） 1$ ls -lR| grep &quot;^-&quot; | wc -l 查看某目录下文件夹(目录)的个数（包括子目录） 1$ ls -lR | grep &quot;^d&quot; | wc -l 命令原理： ls -l 详细输出该文件夹下文件信息 ls -lR是列出所有文件，包括子目录 grep &quot;^-&quot; 过滤ls的输出信息，只保留一般文件；只保留目录是grep &quot;^d&quot; wc -l 统计输出信息的行数","categories":[{"name":"Linux","slug":"Linux","permalink":"https://simon-ace.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://simon-ace.github.io/tags/Linux/"}]},{"title":"Python打印更详细的异常信息","slug":"Python打印更详细的异常信息","date":"2019-10-20T16:00:00.000Z","updated":"2020-07-10T03:23:10.782Z","comments":true,"path":"2019/10/21/Python打印更详细的异常信息/","link":"","permalink":"https://simon-ace.github.io/2019/10/21/Python打印更详细的异常信息/","excerpt":"打印Python异常信息的几种方式","text":"打印Python异常信息的几种方式 1 简单的异常信息1234try: a = 1/0except Exception as e: print(e) 打印最简单的message信息： 1division by zero 2 更完整的信息12345678910import tracebacktry: a = 1/0except Exception as e: print('str(e):\\t', e) print('repr(e):\\t', repr(e)) print('traceback.format_exc():\\n%s' % traceback.format_exc()) #字符串 traceback.print_exc() #执行函数 输出： 123456789101112str(e): division by zerorepr(e): ZeroDivisionError(&apos;division by zero&apos;)traceback.format_exc():Traceback (most recent call last): File &quot;/Users/ace/Play/test/异常信息.py&quot;, line 4, in &lt;module&gt; a = 1/0ZeroDivisionError: division by zeroTraceback (most recent call last): File &quot;/Users/ace/Play/test/异常信息.py&quot;, line 4, in &lt;module&gt; a = 1/0ZeroDivisionError: division by zero traceback.format_exc()和traceback.print_exc()都可以打印完整的错误信息 traceback.format_exc()返回值为字符串 traceback.print_exc()是一个执行函数，直接在控制台打印错误信息","categories":[{"name":"Python","slug":"Python","permalink":"https://simon-ace.github.io/categories/Python/"}],"tags":[{"name":"Python, 异常","slug":"Python-异常","permalink":"https://simon-ace.github.io/tags/Python-异常/"}]},{"title":"【转】持续集成 Continuous Integration","slug":"持续集成 Continuous Integration","date":"2019-10-17T16:00:00.000Z","updated":"2020-07-10T03:23:10.782Z","comments":true,"path":"2019/10/18/持续集成 Continuous Integration/","link":"","permalink":"https://simon-ace.github.io/2019/10/18/持续集成 Continuous Integration/","excerpt":"持续集成 Continuous Integration","text":"持续集成 Continuous Integration","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simon-ace.github.io/tags/Hexo/"}]},{"title":"Hexo多台电脑同步","slug":"Hexo多台电脑同步","date":"2019-10-15T16:00:00.000Z","updated":"2020-08-13T09:06:57.490Z","comments":true,"path":"2019/10/16/Hexo多台电脑同步/","link":"","permalink":"https://simon-ace.github.io/2019/10/16/Hexo多台电脑同步/","excerpt":"如果换了电脑该如何同步Hexo的源文件？把hexo文件从一个电脑cope到另外一个电脑吗？答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理。 本文提供一种多台电脑同步源文件的方法。","text":"如果换了电脑该如何同步Hexo的源文件？把hexo文件从一个电脑cope到另外一个电脑吗？答案肯定不是这样的，因为这里面有好多依赖包，好几万个文件呢，这样显然不合理。 本文提供一种多台电脑同步源文件的方法。 0 解决思路使用GitHub的分支！在博客对应的仓库中新建一个分支。一个分支用来存放Hexo生成的网站原始的文件，另一个分支用来存放生成的静态网页。 1 创建分支1.1 创建新分支命令行操作： GitHub操作： 点击branch按钮，输入新的分支名source，点创建。 1.2 设置默认分支准备在source分支中存放源文件，master中存放生成的网页，因此将source设置为默认分支，方便同步文件。 在仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为source，save保存 2 源文件上传到GitHub 选好一个本地文件夹，执行 git clone git@github.com:Simon-Ace/Simon-Ace.github.io.git(替换成你的仓库) 在克隆到本地的Simon-Ace.github.io中，把除了.git 文件夹外的所有文件都删掉 把之前我们写的博客源文件全部复制过来，除了.deploy_git 复制过来的源文件应该有一个.gitignore，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ 注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的.git文件夹删掉，因为git不能嵌套上传。 提交更改 123git add .git commit –m \"add branch\"git push 参考文章： https://juejin.im/post/5acf22e6f265da23994eeac9 https://www.zhihu.com/question/21193762","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simon-ace.github.io/tags/Hexo/"}]},{"title":"Python-加快pip安装速度","slug":"tutorials/Python-加快pip安装速度","date":"2019-10-15T16:00:00.000Z","updated":"2020-07-10T03:23:10.782Z","comments":true,"path":"2019/10/16/tutorials/Python-加快pip安装速度/","link":"","permalink":"https://simon-ace.github.io/2019/10/16/tutorials/Python-加快pip安装速度/","excerpt":"PIP安装时使用国内镜像，加快下载速度","text":"PIP安装时使用国内镜像，加快下载速度 0 国内源清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 1 临时使用 可以在使用pip的时候加参数-i https://pypi.tuna.tsinghua.edu.cn/simple 例如： pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy 2 永久修改这样就不用每次都添加国内镜像源地址了 Linux下，修改~/.pip/pip.conf（没有就创建一个文件夹及文件） 打开文件，添加内容： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com windows下，直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini， 内容同上","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://simon-ace.github.io/tags/Hexo/"}]},{"title":"一台电脑配置多个git账号","slug":"配置多个git账号","date":"2019-10-13T16:00:00.000Z","updated":"2020-07-10T03:28:22.702Z","comments":true,"path":"2019/10/14/配置多个git账号/","link":"","permalink":"https://simon-ace.github.io/2019/10/14/配置多个git账号/","excerpt":"1 清除git全局设置如果配置第一个账号的时候使用git config --global设置过，就先要取消掉，否则两个账号肯定会冲突 123# 取消globalgit config --global --unset user.namegit config --global --unset user.email","text":"1 清除git全局设置如果配置第一个账号的时候使用git config --global设置过，就先要取消掉，否则两个账号肯定会冲突 123# 取消globalgit config --global --unset user.namegit config --global --unset user.email 2 生成新账号的SSH keys2.1 用 ssh-keygen 命令生成密钥1$ ssh-keygen -t rsa -C \"new email\" 平时都是直接回车，默认生成 id_rsa 和 id_rsa.pub。这里特别需要注意，出现提示输入文件名的时候(Enter file in which to save the key (~/.ssh/id_rsa): id_rsa_new)要输入与默认配置不一样的文件名，比如：我这里填的是 id_rsa和id_rsa_me。 如果之前没配置过ssh key，这里用不同邮箱生成两遍即可，注意用不同的文件名 成功后会出现： 12Your identification has been saved in xxx.Your public key has been saved in xxx. 2.2 添加到ssh-agent中使用ssh-add将 IdentityFile 添加到 ssh-agent中 12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_me 2.3 配置 ~/.ssh/config 文件在~/.ssh/下新建config文件 1234567891011# The git info for companyHost git.XXX.com # git别名，写公司的git名字即可HostName git.XXX.com # git名字，同样写公司的git名字User git # 写 git 即可IdentityFile ~/.ssh/id_rsa #私钥路径，若写错会连接失败# The git info for github Host github.com # git别名，写github的git名字即可HostName github.com # git名字，同样写github的git名字User git # 写 git 即可IdentityFile ~/.ssh/id_rsa_me #私钥路径，若写错会连接失败 3 与GitHub链接复制刚刚生成的两个ssh公钥到对应的账号中 文件id_rsa.pub中保存的就是 ssh 公钥 12pbcopy &lt; ~/.ssh/id_rsa.pubpbcopy &lt; ~/.ssh/id_rsa_me.pub 在 github 网站中添加该 ssh 公钥 验证是否配置成功，以 github 为例，输入 ssh -T git@github.com，若出现 1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 这样的字段，即说明配置成功。另一个同理。 参考链接： 配置多个git账号的ssh密钥 - 掘金https://juejin.im/post/5befe84d51882557795cc8f9 同一台电脑配置多个git账号 · Issue #2 · jawil/noteshttps://github.com/jawil/notes/issues/2","categories":[{"name":"教程","slug":"教程","permalink":"https://simon-ace.github.io/categories/教程/"}],"tags":[{"name":"git","slug":"git","permalink":"https://simon-ace.github.io/tags/git/"}]}]}